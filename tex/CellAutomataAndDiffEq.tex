% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage{german}
%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margins=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{german}
\usepackage{url}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{listings}
% These packages are all incorporated in the memoir class to one degree or another...

\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   %numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% The "real" document content comes below...

\theoremstyle{definition}
\newtheorem*{beisp}{Beispiel}
\newtheorem{definition}{Definition}
\newtheorem*{bemerkung}{Bemerkung}

\title{Darstellung von Differentialgleichungen mit einem zellulären Automaten}
\author{Detlev Ziereisen, Florian Lüthi, i10b}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\tableofcontents

\section{Einleitung}

Diese Projektarbeit (bestehend aus diesem Dokument sowie der zugehörigen Software {\tt Tusk}) hat zum Ziel, partielle Differentialgleichungen aus dem Umfeld der physikalischen Simulationen mit einem zellulären Automaten zu berechnen sowie darzustellen. Es soll gezeigt werden, dass dies unter den konzeptionellen Restriktionen der Theorie der zellulären Automaten möglich ist, insbesondere soll die Annahme Konrad Zuses, dass die Naturgesetze diskreten Regeln folgten und das gesamte Geschehen im Universum das Ergebnis der Arbeit eines gigantischen zellulären Automaten sei \cite{wiki:zellautomat, zuse1969}, zumindest für den Scope dieser Arbeit bestätigt werden. Ausserdem soll gezeigt werden, dass die intuitiv erwarteten Resultate in sinnvoller Rechenzeit dargestellt werden können.

Diese Projektarbeit wurde im Rahmen des Kurses Softwareprojekt 2 an der Hochschule für Technik Zürich durchgeführt. Der Quellcode sowie auch dieses Dokument sind Online auf \url{http://www.github.com/foyan/Tusk} zu finden.

Der Autoren Dank geht (in alphabetischer Reihenfolge der Vornamen) an Albert Heuberger für geballte mathematische Kompetenz gepaart mit unendlicher Geduld, an Lukas Eppler für die ständige Begleitung, sowie an Philippe Nahlik für die tolle Kursführung.

\section{Zelluläre Automaten}

\begin{quote}Ein zellulärer Automat ist eine regelmäßige Annordnung von Zellen. Jede Zelle kann eine endliche Zahl
von Werten / Zuständen annehmen und hat eine begrenzte Zahl von Nachbarzellen, die sie beeinflussen
können. Das Muster des gesamten zellulären Automaten ändert sich in einzelnen Schritten, die durch eine
Reihe von Übergangsregeln bestimmt werden, die für alle Zellen gelten.\cite{beckmann}\end{quote}

Also:

\begin{definition}[Zellulärer Automat] Ein zellulärer Automat ist durch folgende Eigenschaften festgelegt:
\begin{itemize}
\item einen Zellularraum $R$,
\item eine endliche Nachbarschaft $N$, wobei $\forall r \in R \left(N_r \subset R\right)$,
\item eine Zustandsmenge $Q$,
\item eine Überführungsfunktion $\delta: Q^{|N| + 1}\mapsto Q$.
\end{itemize}
Die Zustandsübergänge erfolgen für alle Zellen nach derselben Überführungsfunktion und gleichzeitig. Die Zellzustände können wie die Zeitschritte diskret sein. \cite{wiki:zellautomat}

\end{definition}

\begin{bemerkung}
Aus dieser Definition folgt unmittelbar, dass der neue Zustand einer Zelle nur vom momentanen Zustand dieser Zelle sowie den Zuständen der Nachbarzellen abhängig sein kann.
\end{bemerkung}

Für zweidimensional organisierte $R$ sind zwei Arten von Nachbarschaft üblich:
\begin{description}
\item[Von-Neumann-Nachbarschaft] Die Nachbarschaft besteht jeweils aus den vier geographisch nächsten Nachbarzellen: $N_{i,j} = \left\{ R_{i,j-1}, R_{i,j+1}, R_{i-1,j}, R_{i+1,j}\right\}$
\item[Moore-Nachbarschaft] Die Nachbarschaft besteht jeweils aus allen Zellen der Von-Neumann-Nachbarschaft sowie zusätzlich der diagonalen Nachbarzellen:

$N_{i,j} = \left\{ R_{i,j-1}, R_{i,j+1}, R_{i-1,j}, R_{i+1,j},R_{i-1,j-1}, R_{i-1,j+1}, R_{i-1,j+1}, R_{i+1,j+1} \right\}$ \cite{schurr}
\end{description}

\begin{beisp}[Wolfram's eindimensionales Universum] Stephen Wolfram\footnote{Stephen Wolfram (* 29. August 1959), britischer Physiker und Mathematiker, Schöpfer der Software Mathematica sowie der Suchmaschine Wolfram Alpha \cite{wiki:wolfram}} definiert in \cite{wolfram2002} und in etlichen Arbeiten aus der Mitte der 1980er-Jahre einen parametrierbaren zellulären Automaten, der nur aus einer einzigen Raumdimension besteht\cite{wiki:wolfram}. In seiner einfachsten Ausprägung ist die Nachbarschaft $N_i$ definiert als $\left\{ R_{i-1}, R_{i+1} \right\}$, und jede Zelle kann genau zwei Zustände annehmen (tot und lebendig bzw. $0$ und $1$). Damit ist
\begin{equation*}
\delta : \left\{0,1\right\}^{|\left\{ R_{i-1}, R_{i+1}\right\}|+ 1} \mapsto \left\{0,1\right\} = \left\{0,1\right\}^3 \mapsto \left\{0,1\right\},
\end{equation*}
ergo existieren 8 mögliche Zustandsänderungen. Ein Beispiel:

\begin{table}[here]
\begin{center}
\begin{tabular}{|r||c|c|c|c|c|c|c|c|}
\hline
alte $R_{i-1}R_iR_{i+1}$ &111& 110 & 101 &100 &011 &010 &001 &000  \\\hline
neues $R_i$ & 0 & 1 & 1 & 0& 1 & 1 & 1 & 0 \\\hline
\end{tabular}
\end{center}
\caption{Wolfram-Konfugration 110}
\label{wolfram110}
\end{table}

Man stellt nun fest, dass bei 8 möglichen Zustandsänderungen für die Anzahl der möglichen Konfigurationen gilt:
\begin{equation*}
|K| = |Q|^{|\operatorname{dom}(\delta)|} = 2^8 = 256.
\end{equation*}
Jeder dieser Konfigurationen kann eine natürliche Zahl $\left\{0, 1, 2, \dots, 255\right\}$ zugeordnet werden, indem die neuen $R_i$ wie oben tabelliert und pro Zeile als binäre Zahl aufgefasst werden \cite{betz2003}:

\begin{table}[here]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c||l|}
\hline
111 & 110 & 101 &100 &011 &010 &001 &000 & Zahl \\\hline\hline
 0 & 0 & 0 & 0& 0 & 0 & 0 & 0 & $00000000_b = 0_d$ \\\hline
 0 & 0 & 0 & 0& 0 & 0 & 0 & 1 & $00000001_b = 1_d$ \\\hline
 0 & 0 & 0 & 0& 0 & 0 & 1 & 0 & $00000010_b = 2_d$ \\\hline
\multicolumn{9}{|c|}{$\vdots$} \\\hline
 0 & 1 & 1 & 0& 1 & 1 & 1 & 0 & $01101110_b = 110_d$ \\\hline
\multicolumn{9}{|c|}{$\vdots$} \\\hline
 1 & 1 & 1 & 1& 1 & 1 & 1 & 1 & $11111111_b = 255_d$ \\\hline
\end{tabular}
\end{center}
\caption{Alle Wolfram-Konfigurationen}
\label{wolframalle}
\end{table}

Dadurch ist es möglich, sämtliche eindimensionalen Wolfram-Universen durch eine einzige Zahl zu identifizieren.

Als besonders spannend hat sich die in Tabelle \ref{wolfram110} dargestellte Konfiguration 110 erwiesen, weil sie die Eigenschaft hat, ein Turing-vollständiges System zu sein \cite{betz2003, wolfram2002}. Dadurch ist sie die Konfiguration einer universellen Turingmaschine, die mit nur 2 Zuständen und 5 Symbolen umgesetzt werden kann -- somit hat die Wolfram-Konfiguration 110 als Turingmaschine einen Umfang von $2\cdot 5 = 10$ und zählt damit zu den kleinsten bis dato bekannten Turingmaschinen \cite{betz2003}.

\end{beisp}

\begin{beisp}[Game of Life]

\newcommand{\ql}{q_\textrm{lebend}}
\newcommand{\qt}{q_\textrm{tot}}

Das von Conway\footnote{John Horton Conway (* 26. Dezember 1937), englischer Mathematiker\cite{wiki:conway}} 1970 entworfene Game of Life ist eine bis heute populäre Umsetzung der Automatentheorie und insbesondere der Idee der zellulären Automaten \cite{wiki:gameoflife}.

Der ursprüngliche Entwurf befindet sich in einem zweidimensionalen $R$ unter Verwendung der Moore-Nachbarschaft. Die Zellen können zwei mögliche Zustände $\left\{\ql, \qt \right\}$ annehmen, und die Übergangsfunktion ist definiert als:
\begin{equation*}
\delta(r, N) = \begin{cases}
\ql & (r = \qt \land \varsigma(\ql,N) = 3) \\
\qt & (r = \ql \land \varsigma(\ql, N) < 2) \\
\ql & (r = \ql \land 2 \leq \varsigma(\ql, N) \leq 3) \\
\qt & (r = \ql \land  \varsigma(\ql, N) > 3) \\
\qt & (\textrm{sonst})
\end{cases}
\end{equation*}
unter Zuhilfenahme der Statuszählfunktion
\begin{equation*}
\varsigma(q, N) = \sum\limits_{i=1}^8  \begin{cases} 1 & (N_i = q) \\ 0 & (N_i \neq q) \end{cases}
\end{equation*}

\end{beisp}

\section{Vom zellulären Automaten zur Differentialgleichung}

Die Berechnung und Darstellung physikalischer Begebenheiten (allgemein ausgedrückt durch folgende partielle Differentialgleichung, mit $u: u(\vec{x}, t)$)
\begin{equation*}
k_n \frac{\partial^n u}{\partial t^n} + k_{n-1} \frac{\partial^{n-1} u}{\partial t^{n-1}} + \cdots + k_1 \frac{\partial u}{\partial t} + k_0 = \frac{\partial^n u}{\partial  \vec{x}^n} + \frac{\partial^{n-1}}{\partial \vec{x}^{n-1}} + \cdots + \frac{\partial u}{\partial \vec{x}}
\end{equation*}
mit zellulären Automaten kann durchgeführt werden, indem folgendes getan wird:
\begin{itemize}
\item $R$ entspricht einer sinnvollen (groben) Diskretisierung der örtlichen Variablen $\vec{x}$ in einer, zwei oder drei Dimensionen
\item Jede Zelle in $R$ ist ein Tupel $(Q, D)$ mit $Q$ als einer Menge von berechnungsfernen Zustandsinformationen und den Differentialen nach der Zeit $D = \left( u, \frac{\partial u}{t}, \frac{\partial^2 u}{\partial t^2}, \cdots, \frac{\partial^n u}{t^n} \right)  \in \mathbb{R}^n$
\item Eine neue Generation entspricht jeweils der fortgelaufenen Zeit $\partial t$, welche sehr fein diskretisiert werden muss
\item In der Übergangsfunktion $\delta$ steckt die eigentliche Differentialgleichung. In der Regel verändert sie nur die Elemente von $D$.
\end{itemize}

\section{$\delta$ der Wellengleichung}

Ausgehend von der homogenen Wellengleichung
\begin{equation*}
\frac{\partial^2 u}{\partial t^2} = k\cdot \frac{\partial^2 u}{\partial \vec{x}^2}
\end{equation*}
und folgenden Zusammenhängen:
%\begin{equation*}
%\begin{array}{rcl}
\begin{align*}
u_i &&& u_i(t+\Delta t) = u_i(t) +  \frac{\partial u_i(t+\Delta t)}{\partial t}\Delta t \\
\downarrow &&& \uparrow \\
\frac{\partial u_i}{\partial \vec x} = u_i - \sum u_{i-1} &&& \frac{\partial u_i(t+\Delta t)}{\partial t} = \frac{\partial u_i(t)}{\partial t} + \frac{\partial^2 u}{\partial t^2}\Delta t \\
\downarrow &&& \uparrow \\
\frac{\partial^2 u_i}{\partial \vec x^2} = -2u_i + \sum u_{i-1} + \sum u_{i+1} & \underbrace{\longrightarrow}_{\frac{\partial^2 u}{\partial t^2} = k\cdot \frac{\partial^2 u}{\partial \vec{x}^2}} && \frac{\partial^2 u}{\partial t^2}
\end{align*}
%\end{array}
%\end{equation*}
sowie unter der Annahme, dass die Richtung der Nachbarzellen bekannt sind (d.h. jeweils der Vorgänger beziehungsweise der Nachfolger innerhalb einer Dimension bekannt sind und deswegen $N$ auch ausgedrückt werden kann als:)
\[
N^* =\begin{pmatrix} \overbrace{n_{1,1} \in N}^{\textrm{1. Dimension}} & \overbrace{n_{2,1} \in N}^{\textrm{2. Dimension}} & \cdots & \overbrace{n_{\frac{1}{2}|N|, 1} \in N}^{\textrm{$\frac{1}{2}|N|$te Dimension}} & \textrm{Vorgänger} \\
n_{1,2} \in N & n_{2,2} \in N & \cdots & n_{\frac{1}{2}|N|, 2} \in N & \textrm{Nachfolger}
 \end{pmatrix}
\]

kann die Übergangsfunktion $\delta$ für die Wellengleichung folgendermassen formuliert werden:

\begin{eqnarray*}
\delta(r, N^*) = 
\end{eqnarray*}

\section{$\delta$ der Ente}

Zu jeder ernstzunehmenden Simulation von Wasser gehören sich darin (aktiv oder passiv) bewegende Objekte -- im Idealfall sind das Enten. Die Differentialgleichung der Badeente im Wasser lautet:
\[
\frac{\partial \vec{x}}{\partial t} = k\cdot \frac{\partial u}{\partial \vec{x}}
\]
Sprich: der Geschwindigkeitsvektor im $\vec{x}$-Vektorfeld (also die Ableitung nach der Zeit $t$) ist abhängig von den Steigungen (also der Differenzen der Höhe $u$) entlang aller Dimensionen.

Speziell dabei ist noch, dass so eine Ente natürlich nur in endlich vielen Zellen vorkommen kann. Da die $\vec{x}$-Komponente 

\section{Numerische Verfahren}

\section{Bemerkungen zur Implementation}

\subsection{Wahl des Umfelds}

Die Wahl des Umfelds fiel auf eine Kombination aus JavaScript und dem HTML5-{\tt canvas}-Element für die grafische Ausgabe. Die hauptsächlichen Gründe dafür sind die einfache Umsetzung sowie die sehr gute Portabilität, vorallem auch auf portable Devices mit Touch-Bedienung. Dadurch kommt der primäre Use Case der Software (Bewegung einer Flüssigkeit mittels dem Pointing Input) besonders gut zur Geltung, weil der Input eben mit dem Finger vorgenommen werden kann.

Bedenken wurden vorgängig und während der ersten Implementierungsphase vor allem in Bezug auf die Perfomance geäussert, konnten aber im Laufe des Projekts zerstreut werden, auch weil gezeigt werden konnte, dass Optimierungen möglich sind (paralleles Berechnen, Umstellung von Vektorgrafik-Operationen auf Bitmap-Manipulationen).

Als Alternativen waren das Game-Framework XNA sowie die 3D-LED-Installation in der Haupthalle des Zürcher Hauptbahnhofs in Betracht gezogen worden.

\subsection{Architektur}

\subsection{\tt CellularAutomata}

Die Klasse {\tt CellularAutomata} hält die einzelnen Zellen, kontrolliert den Ablauf der Time-Slices und verarbeitet die Rückgabewerte der Gleichungsimplementation.

Sie besitzt eine sehr nützliche Hilfsmethode, die sowohl von ihr selber wie auch beispielsweise von der {\tt View}-Klasse benutzt wird:

\begin{lstlisting}
this.forEachCell = function(fn) {
	for (var x = 0; x < this.cols; x++) {
		for (var y = 0; y < this.rows; y++) {
			var cell = this.model[x][y];
			fn(cell);
		}
	}
};
\end{lstlisting}

\subsubsection{Initialisierung der Zellen}

Zu Anfang werden alle Zellen des Automaten hergestellt und initialisiert:
\begin{lstlisting}
this.initCells = function() {
	this.createCells();
	this.wireNeighbourCells();
};
\end{lstlisting}

Die Daten jeder Zelle sind abhängig von der gewählten {\tt Tusk}-Implementation und werden entsprechend von ihr selber initialisiert:

\begin{lstlisting}
this.createCells = function() {
	// [...]
	if (tusk != null) {
		cell.currentData = tusk.createCellData();
	}
	// [...]
}
\end{lstlisting}

Danach werden noch alle Zellen mit ihren Nachbarn verknüpft. Da die Art der Nachbarschaft (Von-Neumann, Moore...) wiederum von der gewählten {\tt Tusk}-Implementation abhängig ist, wird die entsprechende Implementation herangezogen\footnote{Ein Wort zu der auf den ersten Blick unnötig komplizierten Definition der von {\tt this.forEachCell()} auszuführenden anonymen Funktion: In JavaScript wird der Scope von Variablen durch die Funktion und nicht den Block begrenzt, darum gilt als Best Practice zur expliziten Scope-Gebung im Allgemeinen das Wrappen in einer anonymen Funktion und unmittelbarer Ausführung derselben \cite{UnderstandingClosures}.}:

\begin{lstlisting}
this.wireNeighbourCells = function() {
	if (tusk != null) {
		this.forEachCell(
			(function(automata) {
				return function(cell) {
					cell.neighbours = this.tusk.getNeighbours(cell, automata.model);
				};
			})(this)
		);
	}
}
\end{lstlisting}

Es macht sehr viel Sinn, die Zell-Nachbarschaften während der Initialisierung des Automaten vorzunehmen; zum einen, weil sie sich während der Iterierung nicht mehr ändern werden, zum anderen, weil die Zellen im Automaten in einem $n$-dimensionalen Array abgelegt sind, auf das dann bei jedem Iterationsschritt mindestens
\[
	z_{\textrm{min}} = |R| \cdot |N|
\]
zugegriffen werden müsste (wobei $R$ der ganze Zellraum und $N$ die Menge der Nachbarzellen einer Zelle sei).

\subsubsection{Ein Iterationsschritt}

\subsection{Grafische Ausgabe}

Die grafische Ausgabe des zellulären Automaten findet in einem {\tt canvas}-Element statt, in das mittels JavaScript-Code gezeichnet wird. Die dafür zuständigen Klassen heissen {\tt ...CanvasPainter}, wovon verschiedene Implementationen verfügbar sind. Es wird davon ausgegangen, dass jeder {\tt ...CanvasPainter} folgende Methoden anbietet:

\begin{description}
\item[\tt begin()] Beginnt den Zeichnungszyklus.
\item[\tt updateCellView(cell)] Zeichnet eine einzelne Zelle ({\tt cell}) neu.
\item[\tt drawDuck(duck, cell)] Zeichnet eine Ente ({\tt duck}) in eine einzelne Zelle ({\tt cell}).
\item[\tt end()] Beendet den Zeichnungszyklus.
\end{description}

Die Methoden {\tt begin()} und {\tt end()} sind für Implementationen gedacht, die sich nur sinnvoll verhalten wenn sie den gesamten {\tt canvas} neu bezeichnen können und deswegen nach einem atomaren Aufruf von {\tt updateCellView()} einen inkonsistenten Zustand aufweisen.

In den folgenden Abschnitten sind die verfügbaren Implementationen grob erklärt. Es existiert ausserdem eine {\tt Noop}-Implementation, die aber trivial ist und verwendet werden kann, um die grafische Ausgabe komplett abzuschalten.

\subsubsection{{\tt VectorCanvasPainter}}

Diese Klasse bezeichnet den {\tt canvas} durch Vektorgrafik-Operationen:

\begin{lstlisting}
this.updateCellView = function(cell) {
	var du = cell.currentGradients; // get values
	var x = cell.x * scaleWidth; // calculate x position in pixels
	var y = cell.y * scaleHeight; //  calculate y position in pixels
	var baseColor = this.getBaseColor(); // get base painter color
	// let Tusk calculate actual cell color, and format it as 'rgb(r,g,b)'
	var color = getFormattedColor(du[this.getUIndex()], baseColor.r, baseColor.g, baseColor.b);
	this.context.fillStyle = color;
	// draw and fill a rectangle.
	this.context.fillRect(x, y, scaleWidth, scaleHeight);
};
\end{lstlisting}

\subsubsection{{\tt PixelCanvasPainter}}

Diese Klasse bezeichnet den {\tt canvas} durch direkte Pixel-Manipulationen. Grundsätzlich funktionert das folgendermassen \cite{mdn:PixelCanvasDoku}:

\begin{lstlisting}
var myImageData = context.createImageData(cssWidth, cssHeight);
// ... do manipulation here ...
context.putImageData(myImageData, 0, 0);
\end{lstlisting}

Es muss allerdings gesagt werden, dass die Methode {\tt putImageData()} in allen verfügbaren Implementationen (Gecko, WebKit usw.) einigermassen langsam ist. Dies wird vor allem damit erklärt, dass das zu manipulierende Pixel-Array ({\tt myImageData.data} in unserem Beispiel) ein Array von Integern ist, das von {\tt putImageData()} jeweils noch durchlaufen und auf Gültigkeit (Werte $\in [0: 255]$) geprüft werden muss.

Andrew J. Baker zeigt nun in \cite{mdn:PixelCanvas} einen Weg, durch den die Pixelmanipulationen drastisch beschleunigt werden können (solange die verwendete Implementation den Typ {\tt Uint8ClampedArray} unterstützt, wie vom HTML5-Standard  \cite{wthree:twodcanvas} eigentlich vorgesehen).

Dazu ist es erst einmal nötig, in {\tt begin()} die Pixel-Daten vorzubereiten:

\begin{lstlisting}
this.begin = function() {
	this.imageData = this.context.createImageData(WIDTH, HEIGHT);
	this.buf = new ArrayBuffer(this.imageData.data.length);
	this.buf8 = new Uint8ClampedArray(this.buf);
	this.data = new Uint32Array(this.buf);
};
\end{lstlisting}

Dadurch ist es möglich, die in {\tt this.data} enthaltenen Daten als ganze Pixel zu bearbeiten (und nicht den Alpha-, Rot-, Grün- und Blau-Kanal einzeln):

\begin{lstlisting}
this.updateCellView = function(cell) {
	/* [...] */
	for (var ix = x; ix < x + scaleWidth; ix++) {
		for (var iy = y; iy < y + scaleHeight; iy++) {
			var p = (iy * WIDTH + ix);		
			this.data[p] =
				(255   << 24) | // alpha
				(color.b << 16) |
				(color.g <<  8) |
				color.r;
		}
	}
	/* [...] */
}
\end{lstlisting}

Abschliessend werden dann die manipulierten Pixel wieder zurückgeschrieben:

\begin{lstlisting}
this.end = function() {
	this.imageData.data.set(this.buf8);
	this.context.putImageData(this.imageData, 0, 0);
};
\end{lstlisting}

\section{Schlussfolgerung}

\bibliography{biblio}
\bibliographystyle{plain}

\end{document}
